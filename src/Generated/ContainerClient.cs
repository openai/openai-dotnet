// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using OpenAI;
using OpenAI.VectorStores;

namespace OpenAI.Containers
{
    internal partial class ContainerClient
    {
        private readonly Uri _endpoint;

        protected ContainerClient()
        {
        }

        internal ContainerClient(ClientPipeline pipeline, Uri endpoint)
        {
            _endpoint = endpoint;
            Pipeline = pipeline;
        }

        public ClientPipeline Pipeline { get; }

        public virtual ClientResult GetContainers(int? limit, string order, string after, RequestOptions options)
        {
            using PipelineMessage message = CreateGetContainersRequest(limit, order, after, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> GetContainersAsync(int? limit, string order, string after, RequestOptions options)
        {
            using PipelineMessage message = CreateGetContainersRequest(limit, order, after, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult<InternalContainerListResource> GetContainers(int? limit = default, VectorStoreCollectionOrder? order = default, string after = default, CancellationToken cancellationToken = default)
        {
            ClientResult result = GetContainers(limit, order?.ToString(), after, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue((InternalContainerListResource)result, result.GetRawResponse());
        }

        public virtual async Task<ClientResult<InternalContainerListResource>> GetContainersAsync(int? limit = default, VectorStoreCollectionOrder? order = default, string after = default, CancellationToken cancellationToken = default)
        {
            ClientResult result = await GetContainersAsync(limit, order?.ToString(), after, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue((InternalContainerListResource)result, result.GetRawResponse());
        }

        public virtual ClientResult CreateContainer(BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateContainerRequest(content, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> CreateContainerAsync(BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateContainerRequest(content, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult<InternalContainerResource> CreateContainer(InternalCreateContainerBody body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            ClientResult result = CreateContainer(body, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue((InternalContainerResource)result, result.GetRawResponse());
        }

        public virtual async Task<ClientResult<InternalContainerResource>> CreateContainerAsync(InternalCreateContainerBody body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            ClientResult result = await CreateContainerAsync(body, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue((InternalContainerResource)result, result.GetRawResponse());
        }

        public virtual ClientResult RetrieveContainer(string containerId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            using PipelineMessage message = CreateRetrieveContainerRequest(containerId, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> RetrieveContainerAsync(string containerId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            using PipelineMessage message = CreateRetrieveContainerRequest(containerId, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult<InternalContainerResource> RetrieveContainer(string containerId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            ClientResult result = RetrieveContainer(containerId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue((InternalContainerResource)result, result.GetRawResponse());
        }

        public virtual async Task<ClientResult<InternalContainerResource>> RetrieveContainerAsync(string containerId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            ClientResult result = await RetrieveContainerAsync(containerId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue((InternalContainerResource)result, result.GetRawResponse());
        }

        public virtual ClientResult DeleteContainer(string containerId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            using PipelineMessage message = CreateDeleteContainerRequest(containerId, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> DeleteContainerAsync(string containerId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            using PipelineMessage message = CreateDeleteContainerRequest(containerId, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult<InternalDeleteContainerResponse> DeleteContainer(string containerId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            ClientResult result = DeleteContainer(containerId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue((InternalDeleteContainerResponse)result, result.GetRawResponse());
        }

        public virtual async Task<ClientResult<InternalDeleteContainerResponse>> DeleteContainerAsync(string containerId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            ClientResult result = await DeleteContainerAsync(containerId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue((InternalDeleteContainerResponse)result, result.GetRawResponse());
        }

        public virtual ClientResult CreateContainerFile(string containerId, BinaryContent content, string contentType, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateContainerFileRequest(containerId, content, contentType, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> CreateContainerFileAsync(string containerId, BinaryContent content, string contentType, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateContainerFileRequest(containerId, content, contentType, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult GetContainerFiles(string containerId, int? limit, string order, string after, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            using PipelineMessage message = CreateGetContainerFilesRequest(containerId, limit, order, after, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> GetContainerFilesAsync(string containerId, int? limit, string order, string after, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            using PipelineMessage message = CreateGetContainerFilesRequest(containerId, limit, order, after, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult<InternalContainerFileListResource> GetContainerFiles(string containerId, int? limit = default, VectorStoreCollectionOrder? order = default, string after = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            ClientResult result = GetContainerFiles(containerId, limit, order?.ToString(), after, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue((InternalContainerFileListResource)result, result.GetRawResponse());
        }

        public virtual async Task<ClientResult<InternalContainerFileListResource>> GetContainerFilesAsync(string containerId, int? limit = default, VectorStoreCollectionOrder? order = default, string after = default, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));

            ClientResult result = await GetContainerFilesAsync(containerId, limit, order?.ToString(), after, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue((InternalContainerFileListResource)result, result.GetRawResponse());
        }

        public virtual ClientResult RetrieveContainerFile(string containerId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateRetrieveContainerFileRequest(containerId, fileId, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> RetrieveContainerFileAsync(string containerId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateRetrieveContainerFileRequest(containerId, fileId, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult<InternalContainerFileResource> RetrieveContainerFile(string containerId, string fileId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = RetrieveContainerFile(containerId, fileId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue((InternalContainerFileResource)result, result.GetRawResponse());
        }

        public virtual async Task<ClientResult<InternalContainerFileResource>> RetrieveContainerFileAsync(string containerId, string fileId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = await RetrieveContainerFileAsync(containerId, fileId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue((InternalContainerFileResource)result, result.GetRawResponse());
        }

        public virtual ClientResult DeleteContainerFile(string containerId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateDeleteContainerFileRequest(containerId, fileId, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> DeleteContainerFileAsync(string containerId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateDeleteContainerFileRequest(containerId, fileId, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult<InternalDeleteContainerFileResponse> DeleteContainerFile(string containerId, string fileId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = DeleteContainerFile(containerId, fileId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue((InternalDeleteContainerFileResponse)result, result.GetRawResponse());
        }

        public virtual async Task<ClientResult<InternalDeleteContainerFileResponse>> DeleteContainerFileAsync(string containerId, string fileId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = await DeleteContainerFileAsync(containerId, fileId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue((InternalDeleteContainerFileResponse)result, result.GetRawResponse());
        }

        public virtual ClientResult RetrieveContainerFileContent(string containerId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateRetrieveContainerFileContentRequest(containerId, fileId, options);
            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));
        }

        public virtual async Task<ClientResult> RetrieveContainerFileContentAsync(string containerId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateRetrieveContainerFileContentRequest(containerId, fileId, options);
            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        public virtual ClientResult<BinaryData> RetrieveContainerFileContent(string containerId, string fileId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = RetrieveContainerFileContent(containerId, fileId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null);
            return ClientResult.FromValue(result.GetRawResponse().Content, result.GetRawResponse());
        }

        public virtual async Task<ClientResult<BinaryData>> RetrieveContainerFileContentAsync(string containerId, string fileId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(containerId, nameof(containerId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = await RetrieveContainerFileContentAsync(containerId, fileId, cancellationToken.CanBeCanceled ? new RequestOptions { CancellationToken = cancellationToken } : null).ConfigureAwait(false);
            return ClientResult.FromValue(result.GetRawResponse().Content, result.GetRawResponse());
        }
    }
}
